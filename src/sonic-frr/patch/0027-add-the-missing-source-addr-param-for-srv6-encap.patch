From c2324a4e1da46ff7e62f43f1a74ef11e93d789d4 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 17 Nov 2022 00:08:21 +0100
Subject: [PATCH 01/16] zebra: Enhance the `netlink_socket()` API

The `netlink_socket()` function is used in many places to create and
initialize Netlink sockets. Currently it can only create `NETLINK_ROUTE`
sockets.

This commit makes the `netlink_socket()` function reusbable to create
any kind of Netlink socket (e.g., `NETLINK_GENERIC` sockets). It extends
the `netlink_socket()` function with a new argument, `nl_family`. The
`nl_family` argument allows developers to provide the Netlink family of
the socket to be created. This reduces the effort to add new Netlink
socket based on different Netlink families.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/kernel_netlink.c | 29 +++++++++++++++++++++--------
 1 file changed, 21 insertions(+), 8 deletions(-)

diff --git a/zebra/kernel_netlink.c b/zebra/kernel_netlink.c
index 42afe6146..95939f1a5 100644
--- a/zebra/kernel_netlink.c
+++ b/zebra/kernel_netlink.c
@@ -313,15 +313,18 @@ static const char *group2str(uint32_t group)
 /* Make socket for Linux netlink interface. */
 static int netlink_socket(struct nlsock *nl, unsigned long groups,
 			  uint32_t ext_groups[], uint8_t ext_group_size,
-			  ns_id_t ns_id)
+			  ns_id_t ns_id, int nl_family)
 {
 	int ret;
 	struct sockaddr_nl snl;
 	int sock;
 	int namelen;
 
+	if (nl_family != NETLINK_ROUTE)
+		return -1;
+
 	frr_with_privs(&zserv_privs) {
-		sock = ns_socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE, ns_id);
+		sock = ns_socket(AF_NETLINK, SOCK_RAW, nl_family, ns_id);
 		if (sock < 0) {
 			zlog_err("Can't open %s socket: %s", nl->name,
 				 safe_strerror(errno));
@@ -386,6 +389,15 @@ static int netlink_socket(struct nlsock *nl, unsigned long groups,
 	return ret;
 }
 
+/* Make socket for Linux route netlink interface. */
+static int rt_netlink_socket(struct nlsock *nl, unsigned long groups,
+			     uint32_t ext_groups[], uint8_t ext_group_size,
+			     ns_id_t ns_id)
+{
+	return netlink_socket(nl, groups, ext_groups, ext_group_size, ns_id,
+			      NETLINK_ROUTE);
+}
+
 /*
  * Dispatch an incoming netlink message; used by the zebra main pthread's
  * netlink event reader.
@@ -1798,8 +1810,8 @@ void kernel_init(struct zebra_ns *zns)
 	snprintf(zns->netlink.name, sizeof(zns->netlink.name),
 		 "netlink-listen (NS %u)", zns->ns_id);
 	zns->netlink.sock = -1;
-	if (netlink_socket(&zns->netlink, groups, &ext_groups, 1, zns->ns_id) <
-	    0) {
+	if (rt_netlink_socket(&zns->netlink, groups, &ext_groups, 1,
+			      zns->ns_id) < 0) {
 		zlog_err("Failure to create %s socket",
 			 zns->netlink.name);
 		exit(-1);
@@ -1810,7 +1822,7 @@ void kernel_init(struct zebra_ns *zns)
 	snprintf(zns->netlink_cmd.name, sizeof(zns->netlink_cmd.name),
 		 "netlink-cmd (NS %u)", zns->ns_id);
 	zns->netlink_cmd.sock = -1;
-	if (netlink_socket(&zns->netlink_cmd, 0, 0, 0, zns->ns_id) < 0) {
+	if (rt_netlink_socket(&zns->netlink_cmd, 0, 0, 0, zns->ns_id) < 0) {
 		zlog_err("Failure to create %s socket",
 			 zns->netlink_cmd.name);
 		exit(-1);
@@ -1823,7 +1835,8 @@ void kernel_init(struct zebra_ns *zns)
 		 sizeof(zns->netlink_dplane_out.name), "netlink-dp (NS %u)",
 		 zns->ns_id);
 	zns->netlink_dplane_out.sock = -1;
-	if (netlink_socket(&zns->netlink_dplane_out, 0, 0, 0, zns->ns_id) < 0) {
+	if (rt_netlink_socket(&zns->netlink_dplane_out, 0, 0, 0, zns->ns_id) <
+	    0) {
 		zlog_err("Failure to create %s socket",
 			 zns->netlink_dplane_out.name);
 		exit(-1);
@@ -1836,8 +1849,8 @@ void kernel_init(struct zebra_ns *zns)
 		 sizeof(zns->netlink_dplane_in.name), "netlink-dp-in (NS %u)",
 		 zns->ns_id);
 	zns->netlink_dplane_in.sock = -1;
-	if (netlink_socket(&zns->netlink_dplane_in, dplane_groups, 0, 0,
-			   zns->ns_id) < 0) {
+	if (rt_netlink_socket(&zns->netlink_dplane_in, dplane_groups, 0, 0,
+			      zns->ns_id) < 0) {
 		zlog_err("Failure to create %s socket",
 			 zns->netlink_dplane_in.name);
 		exit(-1);
-- 
2.20.1


From ae20c1cb8b0c77834aa0614af6240257c1cf22d3 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 17 Nov 2022 00:15:40 +0100
Subject: [PATCH 02/16] zebra: Add new socket for Generic Netlink

zebra already supports several Netlink sockets which allow it to
communicate with the kernel. Each Netlink socket has a specific purpose:
we have a socket for incoming events from the kernel, a socket for
programming the dataplane, a socket for the kernel messages, a socket
used as the command channel. All the currently supported sockets are
based on the `NETLINK_ROUTE` protocol.

In this commit, we add a new Netlink socket that allows zebra to send
commands to the kernel using the `Generic Netlink` protocol.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/kernel_netlink.c | 39 ++++++++++++++++++++++++++++++++++++++-
 zebra/zebra_ns.h       |  2 ++
 2 files changed, 40 insertions(+), 1 deletion(-)

diff --git a/zebra/kernel_netlink.c b/zebra/kernel_netlink.c
index 95939f1a5..04e5c7e7c 100644
--- a/zebra/kernel_netlink.c
+++ b/zebra/kernel_netlink.c
@@ -320,7 +320,7 @@ static int netlink_socket(struct nlsock *nl, unsigned long groups,
 	int sock;
 	int namelen;
 
-	if (nl_family != NETLINK_ROUTE)
+	if (nl_family != NETLINK_ROUTE && nl_family != NETLINK_GENERIC)
 		return -1;
 
 	frr_with_privs(&zserv_privs) {
@@ -398,6 +398,15 @@ static int rt_netlink_socket(struct nlsock *nl, unsigned long groups,
 			      NETLINK_ROUTE);
 }
 
+/* Make socket for Linux generic netlink interface. */
+static int ge_netlink_socket(struct nlsock *nl, unsigned long groups,
+			     uint32_t ext_groups[], uint8_t ext_group_size,
+			     ns_id_t ns_id)
+{
+	return netlink_socket(nl, groups, ext_groups, ext_group_size, ns_id,
+			      NETLINK_GENERIC);
+}
+
 /*
  * Dispatch an incoming netlink message; used by the zebra main pthread's
  * netlink event reader.
@@ -1858,6 +1867,18 @@ void kernel_init(struct zebra_ns *zns)
 
 	kernel_netlink_nlsock_insert(&zns->netlink_dplane_in);
 
+	/* Generic Netlink socket. */
+	snprintf(zns->ge_netlink_cmd.name, sizeof(zns->ge_netlink_cmd.name),
+		 "generic-netlink-cmd (NS %u)", zns->ns_id);
+	zns->ge_netlink_cmd.sock = -1;
+	if (ge_netlink_socket(&zns->ge_netlink_cmd, 0, 0, 0, zns->ns_id) < 0) {
+		zlog_err("Failure to create %s socket",
+			 zns->ge_netlink_cmd.name);
+		exit(-1);
+	}
+
+	kernel_netlink_nlsock_insert(&zns->ge_netlink_cmd);
+
 	/*
 	 * SOL_NETLINK is not available on all platforms yet
 	 * apparently.  It's in bits/socket.h which I am not
@@ -1884,6 +1905,15 @@ void kernel_init(struct zebra_ns *zns)
 		zlog_notice("Registration for extended dp ACK failed : %d %s",
 			    errno, safe_strerror(errno));
 
+	one = 1;
+	ret = setsockopt(zns->ge_netlink_cmd.sock, SOL_NETLINK, NETLINK_EXT_ACK,
+			 &one, sizeof(one));
+
+	if (ret < 0)
+		zlog_err(
+			"Registration for extended generic netlink cmd ACK failed : %d %s",
+			errno, safe_strerror(errno));
+
 	/*
 	 * Trim off the payload of the original netlink message in the
 	 * acknowledgment. This option is available since Linux 4.2, so if
@@ -1916,12 +1946,17 @@ void kernel_init(struct zebra_ns *zns)
 			 zns->netlink_dplane_in.name, safe_strerror(errno),
 			 errno);
 
+	if (fcntl(zns->ge_netlink_cmd.sock, F_SETFL, O_NONBLOCK) < 0)
+		zlog_err("Can't set %s socket error: %s(%d)",
+			 zns->ge_netlink_cmd.name, safe_strerror(errno), errno);
+
 	/* Set receive buffer size if it's set from command line */
 	if (rcvbufsize) {
 		netlink_recvbuf(&zns->netlink, rcvbufsize);
 		netlink_recvbuf(&zns->netlink_cmd, rcvbufsize);
 		netlink_recvbuf(&zns->netlink_dplane_out, rcvbufsize);
 		netlink_recvbuf(&zns->netlink_dplane_in, rcvbufsize);
+		netlink_recvbuf(&zns->ge_netlink_cmd, rcvbufsize);
 	}
 
 	/* Set filter for inbound sockets, to exclude events we've generated
@@ -1969,6 +2004,8 @@ void kernel_terminate(struct zebra_ns *zns, bool complete)
 	 */
 	if (complete)
 		kernel_nlsock_fini(&zns->netlink_dplane_out);
+
+	kernel_nlsock_fini(&zns->ge_netlink_cmd);
 }
 
 /*
diff --git a/zebra/zebra_ns.h b/zebra/zebra_ns.h
index 7a0ffbc1e..10c17d150 100644
--- a/zebra/zebra_ns.h
+++ b/zebra/zebra_ns.h
@@ -62,6 +62,8 @@ struct zebra_ns {
 	struct nlsock netlink_dplane_out;
 	struct nlsock netlink_dplane_in;
 	struct thread *t_netlink;
+
+	struct nlsock ge_netlink_cmd; /* command channel for generic netlink */
 #endif
 
 	struct route_table *if_table;
-- 
2.20.1


From c80db36a6f7ce4c1f8b5584ac6fd3b164318574e Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 09:53:57 +0100
Subject: [PATCH 03/16] zebra: Allow sending data over `ge_netlink_cmd`

In this commit, we add a new function called `ge_netlink_talk()` that
can be used to send commands to the kernel over the `ge_netlink_cmd`
(Generic Netlink) socket.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/kernel_netlink.c | 24 ++++++++++++++++++++++++
 zebra/kernel_netlink.h |  3 +++
 2 files changed, 27 insertions(+)

diff --git a/zebra/kernel_netlink.c b/zebra/kernel_netlink.c
index 04e5c7e7c..13fdfbbf0 100644
--- a/zebra/kernel_netlink.c
+++ b/zebra/kernel_netlink.c
@@ -1287,6 +1287,30 @@ int netlink_talk(int (*filter)(struct nlmsghdr *, ns_id_t, int startup),
 	return netlink_talk_info(filter, n, &dp_info, startup);
 }
 
+/*
+ * Synchronous version of netlink_talk_info. Converts args to suit the
+ * common version, which is suitable for both sync and async use.
+ */
+int ge_netlink_talk(int (*filter)(struct nlmsghdr *, ns_id_t, int startup),
+		    struct nlmsghdr *n, struct zebra_ns *zns, bool startup)
+{
+	struct zebra_dplane_info dp_info;
+
+	/* Increment sequence number before capturing snapshot of ns socket
+	 * info.
+	 */
+	zns->ge_netlink_cmd.seq++;
+
+	/* Capture info in intermediate info struct */
+	dp_info.ns_id = zns->ns_id;
+
+	dp_info.is_cmd = true;
+	dp_info.sock = zns->ge_netlink_cmd.sock;
+	dp_info.seq = zns->ge_netlink_cmd.seq;
+
+	return netlink_talk_info(filter, n, &dp_info, startup);
+}
+
 /* Issue request message to kernel via netlink socket. GET messages
  * are issued through this interface.
  */
diff --git a/zebra/kernel_netlink.h b/zebra/kernel_netlink.h
index 08cd706a9..acb6c1bf5 100644
--- a/zebra/kernel_netlink.h
+++ b/zebra/kernel_netlink.h
@@ -140,6 +140,9 @@ extern int netlink_talk_filter(struct nlmsghdr *h, ns_id_t ns, int startup);
 extern int netlink_talk(int (*filter)(struct nlmsghdr *, ns_id_t, int startup),
 			struct nlmsghdr *n, struct nlsock *nl,
 			struct zebra_ns *zns, bool startup);
+extern int
+ge_netlink_talk(int (*filter)(struct nlmsghdr *, ns_id_t, int startup),
+		struct nlmsghdr *n, struct zebra_ns *zns, bool startup);
 extern int netlink_request(struct nlsock *nl, void *req);
 
 enum netlink_msg_status {
-- 
2.20.1


From 2dffd84399e3b8f0669ebc2d8ee25804e3eb5df1 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 16:16:23 +0100
Subject: [PATCH 04/16] zebra: Allow resolving Generic Netlink family

Generic Netlink supports the dynamic allocation of communication
channels. Communication channels are uniquely identified by channel
numbers which are dynamically allocated by a Generic Netlink controller.
The controller listens on a fixed communication channel (channel number
0x10). Clients who want to use a service query the controller to see if
the service exists and to determine the correct channel number.

In this commit, we add the base functionality to get the channel number
assigned to a specific service. In particular, we add a function
`genl_resolve_family()` that takes the service name (called family in
the Generic Netlink terminology) as input and queries the Generic
Netlink controller to get the channel number that corresponds to the
service.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/ge_netlink.c | 73 ++++++++++++++++++++++++++++++++++++++++++++++
 zebra/ge_netlink.h | 41 ++++++++++++++++++++++++++
 zebra/subdir.am    |  2 ++
 3 files changed, 116 insertions(+)
 create mode 100644 zebra/ge_netlink.c
 create mode 100644 zebra/ge_netlink.h

diff --git a/zebra/ge_netlink.c b/zebra/ge_netlink.c
new file mode 100644
index 000000000..6b98782d2
--- /dev/null
+++ b/zebra/ge_netlink.c
@@ -0,0 +1,73 @@
+/*
+ * Generic Netlink functions
+ * Copyright (C) 2022  Carmine Scarpitta, University of Rome Tor Vergata
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <zebra.h>
+
+#ifdef HAVE_NETLINK
+
+/* The following definition is to workaround an issue in the Linux kernel
+ * header files with redefinition of 'struct in6_addr' in both
+ * netinet/in.h and linux/in6.h.
+ * Reference - https://sourceware.org/ml/libc-alpha/2013-01/msg00599.html
+ */
+#define _LINUX_IN6_H
+
+#include <linux/genetlink.h>
+#include <linux/seg6_genl.h>
+
+#include "lib/ns.h"
+#include "zebra/ge_netlink.h"
+#include "zebra/debug.h"
+#include "zebra/kernel_netlink.h"
+
+
+int genl_resolve_family(const char *family, struct zebra_dplane_ctx *ctx)
+{
+	struct zebra_ns *zns;
+
+	struct {
+		struct nlmsghdr n;
+		struct genlmsghdr g;
+		char buf[1024];
+	} req;
+
+	memset(&req, 0, sizeof(req));
+
+	zns = zebra_ns_lookup(dplane_ctx_get_ns_sock(ctx));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
+	req.n.nlmsg_flags = NLM_F_REQUEST;
+	req.n.nlmsg_type = GENL_ID_CTRL;
+
+	req.n.nlmsg_pid = zns->netlink_cmd.snl.nl_pid;
+
+	req.g.cmd = CTRL_CMD_GETFAMILY;
+	req.g.version = 0;
+
+	if (!nl_attr_put(&req.n, sizeof(req), CTRL_ATTR_FAMILY_NAME, family,
+			 strlen(family) + 1))
+		return 0;
+
+	if (IS_ZEBRA_DEBUG_KERNEL)
+		zlog_debug("Unsupported Generic Netlink family");
+
+	return -1;
+}
+
+#endif /* HAVE_NETLINK */
diff --git a/zebra/ge_netlink.h b/zebra/ge_netlink.h
new file mode 100644
index 000000000..47c8eb0f2
--- /dev/null
+++ b/zebra/ge_netlink.h
@@ -0,0 +1,41 @@
+/* Header file exported by ge_netlink.c to zebra.
+ * Copyright (C) 2022  Carmine Scarpitta, University of Rome Tor Vergata
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; see the file COPYING; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef _ZEBRA_GE_NETLINK_H
+#define _ZEBRA_GE_NETLINK_H
+
+#include "zebra_dplane.h"
+
+#ifdef HAVE_NETLINK
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int genl_resolve_family(const char *family,
+			       struct zebra_dplane_ctx *ctx);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* HAVE_NETLINK */
+
+#endif /* _ZEBRA_GE_NETLINK_H */
diff --git a/zebra/subdir.am b/zebra/subdir.am
index 5c4a87b93..a70d122de 100644
--- a/zebra/subdir.am
+++ b/zebra/subdir.am
@@ -52,6 +52,7 @@ zebra_zebra_SOURCES = \
 	zebra/redistribute.c \
 	zebra/router-id.c \
 	zebra/rt_netlink.c \
+	zebra/ge_netlink.c \
 	zebra/rt_socket.c \
 	zebra/rtadv.c \
 	zebra/rtread_netlink.c \
@@ -140,6 +141,7 @@ noinst_HEADERS += \
 	zebra/router-id.h \
 	zebra/rt.h \
 	zebra/rt_netlink.h \
+	zebra/ge_netlink.h \
 	zebra/rtadv.h \
 	zebra/rule_netlink.h \
 	zebra/table_manager.h \
-- 
2.20.1


From b24abb0907004e4b680c2376629e830d1dba6bb5 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 16:17:51 +0100
Subject: [PATCH 05/16] zebra: Allow resolving Generic Netlink SEG6 family

Generic Netlink supports the dynamic allocation of communication
channels. Communication channels are uniquely identified by channel
numbers which are dynamically allocated by a Generic Netlink controller.
The controller listens on a fixed communication channel (channel number
0x10). Clients who want to use a service query the controller to see if
the service exists and to determine the correct channel number.

Generic Netlink family resolution has been introduced in a previous
commit. In this commit, we extend zebra to discover the channel number
associated with the `SEG6` family. zebra queries the Generic Netlink
controller to get the channel number that corresponds to the
`SEG6` family. Then, it uses `netlink_seg6_genl_parse_family()` to
parse the reply receive from the controller and extract the `SEG6`
channel number.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/ge_netlink.c | 47 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 47 insertions(+)

diff --git a/zebra/ge_netlink.c b/zebra/ge_netlink.c
index 6b98782d2..63d32ba4f 100644
--- a/zebra/ge_netlink.c
+++ b/zebra/ge_netlink.c
@@ -37,6 +37,49 @@
 #include "zebra/kernel_netlink.h"
 
 
+static int16_t seg6_genl_family = -1;
+
+static int netlink_seg6_genl_parse_family(struct nlmsghdr *h, ns_id_t ns_id,
+					  int startup)
+{
+	int len;
+	struct rtattr *tb[CTRL_ATTR_MAX + 1];
+	struct genlmsghdr *ghdr = NLMSG_DATA(h);
+	struct rtattr *attrs;
+
+	if (h->nlmsg_type != GENL_ID_CTRL) {
+		zlog_err(
+			"Not a controller message, nlmsg_len=%d nlmsg_type=0x%x",
+			h->nlmsg_len, h->nlmsg_type);
+		return 0;
+	}
+
+	len = h->nlmsg_len - NLMSG_LENGTH(GENL_HDRLEN);
+	if (len < 0) {
+		zlog_err(
+			"Message received from netlink is of a broken size %d %zu",
+			h->nlmsg_len, (size_t)NLMSG_LENGTH(GENL_HDRLEN));
+		return -1;
+	}
+
+	if (ghdr->cmd != CTRL_CMD_NEWFAMILY) {
+		zlog_err("Unknown controller command %d", ghdr->cmd);
+		return -1;
+	}
+
+	attrs = (struct rtattr *)((char *)ghdr + GENL_HDRLEN);
+	netlink_parse_rtattr(tb, CTRL_ATTR_MAX, attrs, len);
+
+	if (tb[CTRL_ATTR_FAMILY_ID] == NULL) {
+		zlog_err("Missing family id TLV");
+		return -1;
+	}
+
+	seg6_genl_family = *(int16_t *)RTA_DATA(tb[CTRL_ATTR_FAMILY_ID]);
+
+	return 0;
+}
+
 int genl_resolve_family(const char *family, struct zebra_dplane_ctx *ctx)
 {
 	struct zebra_ns *zns;
@@ -64,6 +107,10 @@ int genl_resolve_family(const char *family, struct zebra_dplane_ctx *ctx)
 			 strlen(family) + 1))
 		return 0;
 
+	if (strmatch(family, "SEG6"))
+		return ge_netlink_talk(netlink_seg6_genl_parse_family, &req.n,
+				       zns, false);
+
 	if (IS_ZEBRA_DEBUG_KERNEL)
 		zlog_debug("Unsupported Generic Netlink family");
 
-- 
2.20.1


From 0dbcce25c3e4e8bb6d1b1617b0873f60fa1c234f Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 09:07:59 +0100
Subject: [PATCH 06/16] zebra: Add support for SRv6 encap source address

This commit adds the `encap_src_addr` parameter to the
`struct zebra_srv6`. This parameter represents the source address of the
outer encapsulating IPv6 header. Support for configuring the
`encap_src_addr`parameter will be added in a future commit.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/zebra_srv6.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index f320b9ca0..41625857b 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -32,6 +32,9 @@
 /* SRv6 instance structure. */
 struct zebra_srv6 {
 	struct list *locators;
+
+	/* Source address for SRv6 encapsulation */
+	struct in6_addr encap_src_addr;
 };
 
 /* declare hooks for the basic API, so that it can be specialized or served
-- 
2.20.1


From 0e728b5499aca2b20439afe69ba9f2d3b66fa735 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 09:08:37 +0100
Subject: [PATCH 07/16] zebra: Allow setting the SRv6 encap source address

In this commit, we add a helper function that can be used to set the
source address of the outer encapsulating IPv6 header.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/zebra_srv6.c | 10 ++++++++++
 zebra/zebra_srv6.h |  2 ++
 2 files changed, 12 insertions(+)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index d61e4f804..71507cc91 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -421,6 +421,16 @@ int release_daemon_srv6_locator_chunks(struct zserv *client)
 	return count;
 }
 
+void zebra_srv6_encap_src_addr_set(struct in6_addr *encap_src_addr)
+{
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+
+	if (!encap_src_addr)
+		return;
+
+	memcpy(&srv6->encap_src_addr, encap_src_addr, sizeof(struct in6_addr));
+}
+
 void zebra_srv6_init(void)
 {
 	hook_register(zserv_client_close, zebra_srv6_cleanup);
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 41625857b..2b47a8fd6 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -83,4 +83,6 @@ extern void srv6_manager_release_locator_chunk_call(struct zserv *client,
 extern int srv6_manager_client_disconnect_cb(struct zserv *client);
 extern int release_daemon_srv6_locator_chunks(struct zserv *client);
 
+extern void zebra_srv6_encap_src_addr_set(struct in6_addr *src_addr);
+
 #endif /* _ZEBRA_SRV6_H */
-- 
2.20.1


From 89522628f92c88fc35468d06652eb1c880e13154 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 09:09:09 +0100
Subject: [PATCH 08/16] zebra: Allow clearing the SRv6 encap source addr

In this commit, we add a helper function that can be used to clear the
source address configured for the outer encapsulating IPv6 header.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/zebra_srv6.c | 7 +++++++
 zebra/zebra_srv6.h | 1 +
 2 files changed, 8 insertions(+)

diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 71507cc91..79bfda467 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -431,6 +431,13 @@ void zebra_srv6_encap_src_addr_set(struct in6_addr *encap_src_addr)
 	memcpy(&srv6->encap_src_addr, encap_src_addr, sizeof(struct in6_addr));
 }
 
+void zebra_srv6_encap_src_addr_unset(void)
+{
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+
+	memset(&srv6->encap_src_addr, 0, sizeof(struct in6_addr));
+}
+
 void zebra_srv6_init(void)
 {
 	hook_register(zserv_client_close, zebra_srv6_cleanup);
diff --git a/zebra/zebra_srv6.h b/zebra/zebra_srv6.h
index 2b47a8fd6..6ae3c2206 100644
--- a/zebra/zebra_srv6.h
+++ b/zebra/zebra_srv6.h
@@ -84,5 +84,6 @@ extern int srv6_manager_client_disconnect_cb(struct zserv *client);
 extern int release_daemon_srv6_locator_chunks(struct zserv *client);
 
 extern void zebra_srv6_encap_src_addr_set(struct in6_addr *src_addr);
+extern void zebra_srv6_encap_src_addr_unset(void);
 
 #endif /* _ZEBRA_SRV6_H */
-- 
2.20.1


From 8b0f2a19d357ecdb1fc7a838fe56e324a5870678 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 16:23:51 +0100
Subject: [PATCH 09/16] zebra: Add `dplane_sr_tunsrc_ctx` to dataplane

This commit adds a new data plane context `dplane_sr_tunsrc_ctx`
required to support the configuration of the SRv6 encapsulation source
address in the data plane.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/zebra_dplane.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/zebra/zebra_dplane.c b/zebra/zebra_dplane.c
index c8511bd28..572559a9d 100644
--- a/zebra/zebra_dplane.c
+++ b/zebra/zebra_dplane.c
@@ -347,6 +347,13 @@ struct dplane_tc_filter_info {
 	uint32_t classid;
 };
 
+/*
+ * SR tunsrc context for the dataplane
+ */
+struct dplane_sr_tunsrc_ctx {
+	struct in6_addr addr;
+};
+
 /*
  * The context block used to exchange info about route updates across
  * the boundary between the zebra main context (and pthread) and the
@@ -408,6 +415,7 @@ struct zebra_dplane_ctx {
 		struct dplane_neigh_table neightable;
 		struct dplane_gre_ctx gre;
 		struct dplane_netconf_info netconf;
+		struct dplane_sr_tunsrc_ctx sr_tunsrc;
 	} u;
 
 	/* Namespace info, used especially for netlink kernel communication */
-- 
2.20.1


From 3f017cc59081f49760db9a18ba7e33bdd32ec754 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 16:24:52 +0100
Subject: [PATCH 10/16] zebra: Add dplane op for SRv6 encap source address

In this commit, we add a new data plane operation that is used to
configure the SRv6 encapsulation source address in the data plane.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/dplane_fpm_nl.c  |   1 +
 zebra/ge_netlink.c     | 164 +++++++++++++++++++++++++++++++++++++++--
 zebra/ge_netlink.h     |  18 +++++
 zebra/interface.c      |   1 +
 zebra/kernel_netlink.c |   3 +
 zebra/kernel_socket.c  |   1 +
 zebra/zebra_dplane.c   |  83 +++++++++++++++++++++
 zebra/zebra_dplane.h   |  15 +++-
 zebra/zebra_nhg.c      |   1 +
 zebra/zebra_rib.c      |   1 +
 zebra/zebra_script.c   |   1 +
 11 files changed, 282 insertions(+), 7 deletions(-)

diff --git a/zebra/dplane_fpm_nl.c b/zebra/dplane_fpm_nl.c
index b18a96353..48dc104bd 100644
--- a/zebra/dplane_fpm_nl.c
+++ b/zebra/dplane_fpm_nl.c
@@ -953,6 +953,7 @@ static int fpm_nl_enqueue(struct fpm_nl_ctx *fnc, struct zebra_dplane_ctx *ctx)
 	case DPLANE_OP_TC_FILTER_ADD:
 	case DPLANE_OP_TC_FILTER_DELETE:
 	case DPLANE_OP_TC_FILTER_UPDATE:
+	case DPLANE_OP_SR_TUNSRC_SET:
 	case DPLANE_OP_NONE:
 		break;
 
diff --git a/zebra/ge_netlink.c b/zebra/ge_netlink.c
index 63d32ba4f..7d98fa44c 100644
--- a/zebra/ge_netlink.c
+++ b/zebra/ge_netlink.c
@@ -83,12 +83,7 @@ static int netlink_seg6_genl_parse_family(struct nlmsghdr *h, ns_id_t ns_id,
 int genl_resolve_family(const char *family, struct zebra_dplane_ctx *ctx)
 {
 	struct zebra_ns *zns;
-
-	struct {
-		struct nlmsghdr n;
-		struct genlmsghdr g;
-		char buf[1024];
-	} req;
+	struct genl_request req;
 
 	memset(&req, 0, sizeof(req));
 
@@ -117,4 +112,161 @@ int genl_resolve_family(const char *family, struct zebra_dplane_ctx *ctx)
 	return -1;
 }
 
+/*
+ * sr tunsrc change via netlink interface, using a dataplane context object
+ *
+ * Returns -1 on failure, 0 when the msg doesn't fit entirely in the buffer
+ * otherwise the number of bytes written to buf.
+ */
+ssize_t netlink_sr_tunsrc_set_msg_encode(int cmd, struct zebra_dplane_ctx *ctx,
+					 void *buf, size_t buflen)
+{
+	struct nlsock *nl;
+	const struct in6_addr *tunsrc_addr;
+	struct genl_request *req = buf;
+
+	tunsrc_addr = dplane_ctx_get_sr_tunsrc_addr(ctx);
+
+	if (buflen < sizeof(*req))
+		return 0;
+
+	nl = kernel_netlink_nlsock_lookup(dplane_ctx_get_ns_sock(ctx));
+
+	memset(req, 0, sizeof(*req));
+
+	req->n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
+	req->n.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+
+	if (seg6_genl_family < 0)
+		if (genl_resolve_family("SEG6", ctx)) {
+			zlog_err("Generic netlink resolve family failed");
+			return -1;
+		}
+
+	req->n.nlmsg_type = seg6_genl_family;
+
+	req->n.nlmsg_pid = nl->snl.nl_pid;
+
+	req->g.cmd = cmd;
+	req->g.version = SEG6_GENL_VERSION;
+
+	switch (cmd) {
+	case SEG6_CMD_SET_TUNSRC:
+		if (!nl_attr_put(&req->n, buflen, SEG6_ATTR_DST, tunsrc_addr,
+				 sizeof(struct in6_addr)))
+			return 0;
+		break;
+	default:
+		zlog_err("Unsupported command (%u)", cmd);
+		return -1;
+	}
+
+	return NLMSG_ALIGN(req->n.nlmsg_len);
+}
+
+ssize_t netlink_sr_tunsrc_set_msg_encoder(struct zebra_dplane_ctx *ctx,
+					  void *buf, size_t buflen)
+{
+	enum dplane_op_e op;
+	int cmd = 0;
+
+	op = dplane_ctx_get_op(ctx);
+
+	/* Call to netlink layer based on type of operation */
+	switch (op) {
+	case DPLANE_OP_SR_TUNSRC_SET:
+		/* Validate */
+		if (dplane_ctx_get_sr_tunsrc_addr(ctx) == NULL) {
+			if (IS_ZEBRA_DEBUG_KERNEL)
+				zlog_debug(
+					"sr tunsrc set failed: SRv6 encap source address not set");
+			return -1;
+		}
+
+		cmd = SEG6_CMD_SET_TUNSRC;
+
+		break;
+	case DPLANE_OP_ROUTE_INSTALL:
+	case DPLANE_OP_ROUTE_UPDATE:
+	case DPLANE_OP_ROUTE_DELETE:
+	case DPLANE_OP_ROUTE_NOTIFY:
+	case DPLANE_OP_NH_INSTALL:
+	case DPLANE_OP_NH_UPDATE:
+	case DPLANE_OP_NH_DELETE:
+	case DPLANE_OP_LSP_INSTALL:
+	case DPLANE_OP_LSP_UPDATE:
+	case DPLANE_OP_LSP_DELETE:
+	case DPLANE_OP_LSP_NOTIFY:
+	case DPLANE_OP_PW_INSTALL:
+	case DPLANE_OP_PW_UNINSTALL:
+	case DPLANE_OP_SYS_ROUTE_ADD:
+	case DPLANE_OP_SYS_ROUTE_DELETE:
+	case DPLANE_OP_ADDR_INSTALL:
+	case DPLANE_OP_ADDR_UNINSTALL:
+	case DPLANE_OP_MAC_INSTALL:
+	case DPLANE_OP_MAC_DELETE:
+	case DPLANE_OP_NEIGH_INSTALL:
+	case DPLANE_OP_NEIGH_UPDATE:
+	case DPLANE_OP_NEIGH_DELETE:
+	case DPLANE_OP_VTEP_ADD:
+	case DPLANE_OP_VTEP_DELETE:
+	case DPLANE_OP_RULE_ADD:
+	case DPLANE_OP_RULE_DELETE:
+	case DPLANE_OP_RULE_UPDATE:
+	case DPLANE_OP_NEIGH_DISCOVER:
+	case DPLANE_OP_BR_PORT_UPDATE:
+	case DPLANE_OP_IPTABLE_ADD:
+	case DPLANE_OP_IPTABLE_DELETE:
+	case DPLANE_OP_IPSET_ADD:
+	case DPLANE_OP_IPSET_DELETE:
+	case DPLANE_OP_IPSET_ENTRY_ADD:
+	case DPLANE_OP_IPSET_ENTRY_DELETE:
+	case DPLANE_OP_NEIGH_IP_INSTALL:
+	case DPLANE_OP_NEIGH_IP_DELETE:
+	case DPLANE_OP_NEIGH_TABLE_UPDATE:
+	case DPLANE_OP_GRE_SET:
+	case DPLANE_OP_INTF_ADDR_ADD:
+	case DPLANE_OP_INTF_ADDR_DEL:
+	case DPLANE_OP_INTF_NETCONFIG:
+	case DPLANE_OP_INTF_INSTALL:
+	case DPLANE_OP_INTF_UPDATE:
+	case DPLANE_OP_INTF_DELETE:
+	case DPLANE_OP_TC_QDISC_INSTALL:
+	case DPLANE_OP_TC_QDISC_UNINSTALL:
+	case DPLANE_OP_TC_CLASS_ADD:
+	case DPLANE_OP_TC_CLASS_DELETE:
+	case DPLANE_OP_TC_CLASS_UPDATE:
+	case DPLANE_OP_TC_FILTER_ADD:
+	case DPLANE_OP_TC_FILTER_DELETE:
+	case DPLANE_OP_TC_FILTER_UPDATE:
+	case DPLANE_OP_NONE:
+		/* Invalid op */
+		zlog_err(
+			"Context received for kernel sr tunsrc update with incorrect OP code (%u)",
+			op);
+		return -1;
+	}
+
+	return netlink_sr_tunsrc_set_msg_encode(cmd, ctx, buf, buflen);
+}
+
+enum netlink_msg_status
+netlink_put_sr_tunsrc_set_msg(struct nl_batch *bth,
+			      struct zebra_dplane_ctx *ctx)
+{
+	enum dplane_op_e op;
+	struct zebra_ns *zns;
+	struct genl_request req;
+
+	op = dplane_ctx_get_op(ctx);
+	assert(op == DPLANE_OP_SR_TUNSRC_SET);
+
+	netlink_sr_tunsrc_set_msg_encoder(ctx, &req, sizeof(req));
+
+	zns = zebra_ns_lookup(dplane_ctx_get_ns_sock(ctx));
+
+
+	return ge_netlink_talk(netlink_talk_filter, &req.n, zns, false);
+}
+
 #endif /* HAVE_NETLINK */
diff --git a/zebra/ge_netlink.h b/zebra/ge_netlink.h
index 47c8eb0f2..b89fda59d 100644
--- a/zebra/ge_netlink.h
+++ b/zebra/ge_netlink.h
@@ -25,12 +25,30 @@
 
 #ifdef HAVE_NETLINK
 
+#include <linux/genetlink.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+/* Generic Netlink request message */
+struct genl_request {
+	struct nlmsghdr n;
+	struct genlmsghdr g;
+	char buf[1024];
+};
+
 extern int genl_resolve_family(const char *family,
 			       struct zebra_dplane_ctx *ctx);
+extern ssize_t netlink_sr_tunsrc_set_msg_encode(int cmd,
+						struct zebra_dplane_ctx *ctx,
+						void *buf, size_t buflen);
+extern ssize_t netlink_sr_tunsrc_set_msg_encoder(struct zebra_dplane_ctx *ctx,
+						 void *buf, size_t buflen);
+struct nl_batch;
+extern enum netlink_msg_status
+netlink_put_sr_tunsrc_set_msg(struct nl_batch *bth,
+			      struct zebra_dplane_ctx *ctx);
 
 #ifdef __cplusplus
 }
diff --git a/zebra/interface.c b/zebra/interface.c
index 84e52d4b4..d06b1c516 100644
--- a/zebra/interface.c
+++ b/zebra/interface.c
@@ -1590,6 +1590,7 @@ void zebra_if_dplane_result(struct zebra_dplane_ctx *ctx)
 	case DPLANE_OP_TC_FILTER_ADD:
 	case DPLANE_OP_TC_FILTER_DELETE:
 	case DPLANE_OP_TC_FILTER_UPDATE:
+	case DPLANE_OP_SR_TUNSRC_SET:
 		break; /* should never hit here */
 	}
 }
diff --git a/zebra/kernel_netlink.c b/zebra/kernel_netlink.c
index 13fdfbbf0..e31b32521 100644
--- a/zebra/kernel_netlink.c
+++ b/zebra/kernel_netlink.c
@@ -1706,6 +1706,9 @@ static enum netlink_msg_status nl_put_msg(struct nl_batch *bth,
 	case DPLANE_OP_TC_FILTER_DELETE:
 	case DPLANE_OP_TC_FILTER_UPDATE:
 		return netlink_put_tc_filter_update_msg(bth, ctx);
+
+	case DPLANE_OP_SR_TUNSRC_SET:
+		return netlink_put_sr_tunsrc_set_msg(bth, ctx);
 	}
 
 	return FRR_NETLINK_ERROR;
diff --git a/zebra/kernel_socket.c b/zebra/kernel_socket.c
index 684ccc3ed..78a8964f0 100644
--- a/zebra/kernel_socket.c
+++ b/zebra/kernel_socket.c
@@ -1631,6 +1631,7 @@ void kernel_update_multi(struct dplane_ctx_list_head *ctx_list)
 		case DPLANE_OP_GRE_SET:
 		case DPLANE_OP_INTF_ADDR_ADD:
 		case DPLANE_OP_INTF_ADDR_DEL:
+		case DPLANE_OP_SR_TUNSRC_SET:
 			zlog_err("Unhandled dplane data for %s",
 				 dplane_op2str(dplane_ctx_get_op(ctx)));
 			res = ZEBRA_DPLANE_REQUEST_FAILURE;
diff --git a/zebra/zebra_dplane.c b/zebra/zebra_dplane.c
index 572559a9d..fe640a597 100644
--- a/zebra/zebra_dplane.c
+++ b/zebra/zebra_dplane.c
@@ -597,6 +597,9 @@ static struct zebra_dplane_globals {
 	_Atomic uint32_t dg_tcs_in;
 	_Atomic uint32_t dg_tcs_errors;
 
+	_Atomic uint32_t dg_sr_tunsrc_set_in;
+	_Atomic uint32_t dg_sr_tunsrc_set_errors;
+
 	/* Dataplane pthread */
 	struct frr_pthread *dg_pthread;
 
@@ -853,6 +856,7 @@ static void dplane_ctx_free_internal(struct zebra_dplane_ctx *ctx)
 		break;
 	case DPLANE_OP_GRE_SET:
 	case DPLANE_OP_INTF_NETCONFIG:
+	case DPLANE_OP_SR_TUNSRC_SET:
 		break;
 	}
 }
@@ -1176,6 +1180,10 @@ const char *dplane_op2str(enum dplane_op_e op)
 	case DPLANE_OP_TC_FILTER_UPDATE:
 		ret = "TC__FILTER_UPDATE";
 		break;
+
+	case DPLANE_OP_SR_TUNSRC_SET:
+		ret = "SR_TUNSRC_SET";
+		break;
 	}
 
 	return ret;
@@ -2131,6 +2139,16 @@ const struct prefix *dplane_ctx_get_intf_addr(
 	return &(ctx->u.intf.prefix);
 }
 
+
+/* Accessors for SR tunsrc information */
+const struct in6_addr *
+dplane_ctx_get_sr_tunsrc_addr(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return &(ctx->u.sr_tunsrc.addr);
+}
+
 void dplane_ctx_set_intf_addr(struct zebra_dplane_ctx *ctx,
 			      const struct prefix *p)
 {
@@ -5404,6 +5422,58 @@ dplane_gre_set(struct interface *ifp, struct interface *ifp_link,
 	return result;
 }
 
+/*
+ * Common helper api for SR TUNSRC set
+ */
+enum zebra_dplane_result dplane_sr_tunsrc_set(const struct in6_addr *addr,
+					      ns_id_t ns_id)
+{
+	enum zebra_dplane_result result = ZEBRA_DPLANE_REQUEST_FAILURE;
+	struct zebra_dplane_ctx *ctx = NULL;
+	enum dplane_op_e op = DPLANE_OP_SR_TUNSRC_SET;
+	int ret;
+	struct zebra_ns *zns;
+
+	if (!addr)
+		return result;
+
+	if (IS_ZEBRA_DEBUG_DPLANE_DETAIL) {
+		zlog_debug("init dplane ctx %s: addr %pI6", dplane_op2str(op),
+			   addr);
+	}
+
+	zns = zebra_ns_lookup(ns_id);
+	if (!zns)
+		return result;
+
+	ctx = dplane_ctx_alloc();
+
+	ctx->zd_op = op;
+	ctx->zd_status = ZEBRA_DPLANE_REQUEST_SUCCESS;
+
+	dplane_ctx_ns_init(ctx, zns, false);
+
+	/* Init the sr-tunsrc-specific data area */
+	memcpy(&ctx->u.sr_tunsrc.addr, addr, sizeof(ctx->u.sr_tunsrc.addr));
+
+	/* Update counter */
+	atomic_fetch_add_explicit(&zdplane_info.dg_sr_tunsrc_set_in, 1,
+				  memory_order_relaxed);
+
+	/* Enqueue context for processing */
+	ret = dplane_update_enqueue(ctx);
+
+	if (ret == AOK)
+		result = ZEBRA_DPLANE_REQUEST_QUEUED;
+	else {
+		atomic_fetch_add_explicit(&zdplane_info.dg_sr_tunsrc_set_errors,
+					  1, memory_order_relaxed);
+		if (ctx)
+			dplane_ctx_free(&ctx);
+	}
+	return result;
+}
+
 /*
  * Handler for 'show dplane'
  */
@@ -6114,6 +6184,12 @@ static void kernel_dplane_log_detail(struct zebra_dplane_ctx *ctx)
 	case DPLANE_OP_TC_FILTER_DELETE:
 	case DPLANE_OP_TC_FILTER_UPDATE:
 		break;
+
+	case DPLANE_OP_SR_TUNSRC_SET:
+		zlog_debug("Dplane sr tunsrc set op %s, addr %pI6",
+			   dplane_op2str(dplane_ctx_get_op(ctx)),
+			   &ctx->u.sr_tunsrc.addr);
+		break;
 	}
 }
 
@@ -6284,6 +6360,13 @@ static void kernel_dplane_handle_result(struct zebra_dplane_ctx *ctx)
 	case DPLANE_OP_INTF_NETCONFIG:
 		break;
 
+	case DPLANE_OP_SR_TUNSRC_SET:
+		if (res != ZEBRA_DPLANE_REQUEST_SUCCESS)
+			atomic_fetch_add_explicit(
+				&zdplane_info.dg_sr_tunsrc_set_errors, 1,
+				memory_order_relaxed);
+		break;
+
 	case DPLANE_OP_NONE:
 		if (res != ZEBRA_DPLANE_REQUEST_SUCCESS)
 			atomic_fetch_add_explicit(&zdplane_info.dg_other_errors,
diff --git a/zebra/zebra_dplane.h b/zebra/zebra_dplane.h
index ae13243a1..939ac3b75 100644
--- a/zebra/zebra_dplane.h
+++ b/zebra/zebra_dplane.h
@@ -30,6 +30,7 @@
 #include "zebra/zserv.h"
 #include "zebra/zebra_mpls.h"
 #include "zebra/zebra_nhg.h"
+#include "zebra/ge_netlink.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -201,7 +202,10 @@ enum dplane_op_e {
 	DPLANE_OP_TC_CLASS_UPDATE,
 	DPLANE_OP_TC_FILTER_ADD,
 	DPLANE_OP_TC_FILTER_DELETE,
-	DPLANE_OP_TC_FILTER_UPDATE
+	DPLANE_OP_TC_FILTER_UPDATE,
+
+	/* SR tunsrc */
+	DPLANE_OP_SR_TUNSRC_SET,
 };
 
 /*
@@ -550,6 +554,8 @@ bool dplane_ctx_intf_is_broadcast(const struct zebra_dplane_ctx *ctx);
 void dplane_ctx_intf_set_broadcast(struct zebra_dplane_ctx *ctx);
 const struct prefix *dplane_ctx_get_intf_addr(
 	const struct zebra_dplane_ctx *ctx);
+const struct in6_addr *
+dplane_ctx_get_sr_tunsrc_addr(const struct zebra_dplane_ctx *ctx);
 void dplane_ctx_set_intf_addr(struct zebra_dplane_ctx *ctx,
 			      const struct prefix *p);
 bool dplane_ctx_intf_has_dest(const struct zebra_dplane_ctx *ctx);
@@ -877,6 +883,13 @@ enum zebra_dplane_result
 dplane_gre_set(struct interface *ifp, struct interface *ifp_link,
 	       unsigned int mtu, const struct zebra_l2info_gre *gre_info);
 
+/*
+ * Enqueue a SR TUNSRC set
+ */
+enum zebra_dplane_result dplane_sr_tunsrc_set(const struct in6_addr *addr,
+					      ns_id_t ns_id);
+
+
 /* Forward ref of zebra_pbr_rule */
 struct zebra_pbr_rule;
 
diff --git a/zebra/zebra_nhg.c b/zebra/zebra_nhg.c
index 758fed728..f2e1ac6a4 100644
--- a/zebra/zebra_nhg.c
+++ b/zebra/zebra_nhg.c
@@ -3177,6 +3177,7 @@ void zebra_nhg_dplane_result(struct zebra_dplane_ctx *ctx)
 	case DPLANE_OP_TC_FILTER_ADD:
 	case DPLANE_OP_TC_FILTER_DELETE:
 	case DPLANE_OP_TC_FILTER_UPDATE:
+	case DPLANE_OP_SR_TUNSRC_SET:
 		break;
 	}
 }
diff --git a/zebra/zebra_rib.c b/zebra/zebra_rib.c
index 5e50d720a..87165db5c 100644
--- a/zebra/zebra_rib.c
+++ b/zebra/zebra_rib.c
@@ -4769,6 +4769,7 @@ static void rib_process_dplane_results(struct thread *thread)
 			case DPLANE_OP_BR_PORT_UPDATE:
 			case DPLANE_OP_NEIGH_TABLE_UPDATE:
 			case DPLANE_OP_GRE_SET:
+			case DPLANE_OP_SR_TUNSRC_SET:
 			case DPLANE_OP_NONE:
 				break;
 
diff --git a/zebra/zebra_script.c b/zebra/zebra_script.c
index 5c67ad4f1..95d7b0c04 100644
--- a/zebra/zebra_script.c
+++ b/zebra/zebra_script.c
@@ -427,6 +427,7 @@ void lua_pushzebra_dplane_ctx(lua_State *L, const struct zebra_dplane_ctx *ctx)
 	case DPLANE_OP_TC_FILTER_UPDATE:
 		/* Not currently handled */
 	case DPLANE_OP_INTF_NETCONFIG: /*NYI*/
+	case DPLANE_OP_SR_TUNSRC_SET:
 	case DPLANE_OP_NONE:
 		break;
 	} /* Dispatch by op code */
-- 
2.20.1


From ae57860014ae3a081d87c65fed678cc6d5e71757 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 08:40:23 +0100
Subject: [PATCH 11/16] zebra, lib: Add CLI node for SRv6 encap parameters

This commit adds a new node `SRV6_ENCAP_NODE` to the CLI graph. This
node provides configuration parameters related to the SRv6
encapsulation.

```
router# segment-routing
router(sr)# srv6
router(srv6)# encapsulation
router(srv6-encap)#
```

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 lib/command.h          |  1 +
 zebra/zebra_srv6_vty.c | 19 +++++++++++++++++++
 2 files changed, 20 insertions(+)

diff --git a/lib/command.h b/lib/command.h
index 8f5d96053..8825b377a 100644
--- a/lib/command.h
+++ b/lib/command.h
@@ -170,6 +170,7 @@ enum node_type {
 	SRV6_NODE,		 /* SRv6 node */
 	SRV6_LOCS_NODE,		 /* SRv6 locators node */
 	SRV6_LOC_NODE,		 /* SRv6 locator node */
+	SRV6_ENCAP_NODE,		 /* SRv6 encapsulation node */
 	VTY_NODE,		 /* Vty node. */
 	FPM_NODE,		 /* Dataplane FPM node. */
 	LINK_PARAMS_NODE,	/* Link-parameters node */
diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index b4fd5f018..892da125c 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -74,6 +74,13 @@ static struct cmd_node srv6_loc_node = {
 	.prompt = "%s(config-srv6-locator)# "
 };
 
+static struct cmd_node srv6_encap_node = {
+	.name = "srv6-encap",
+	.node = SRV6_ENCAP_NODE,
+	.parent_node = SRV6_NODE,
+	.prompt = "%s(config-srv6-encap)# "
+};
+
 DEFUN (show_srv6_locator,
        show_srv6_locator_cmd,
        "show segment-routing srv6 locator [json]",
@@ -404,6 +411,15 @@ DEFPY (locator_behavior,
 	return CMD_SUCCESS;
 }
 
+DEFUN_NOSH (srv6_encap,
+            srv6_encap_cmd,
+            "encapsulation",
+            "Segment Routing SRv6 encapsulation\n")
+{
+	vty->node = SRV6_ENCAP_NODE;
+	return CMD_SUCCESS;
+}
+
 static int zebra_sr_config(struct vty *vty)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
@@ -457,16 +473,19 @@ void zebra_srv6_vty_init(void)
 	install_node(&srv6_node);
 	install_node(&srv6_locs_node);
 	install_node(&srv6_loc_node);
+	install_node(&srv6_encap_node);
 	install_default(SEGMENT_ROUTING_NODE);
 	install_default(SRV6_NODE);
 	install_default(SRV6_LOCS_NODE);
 	install_default(SRV6_LOC_NODE);
+	install_default(SRV6_ENCAP_NODE);
 
 	/* Command for change node */
 	install_element(CONFIG_NODE, &segment_routing_cmd);
 	install_element(SEGMENT_ROUTING_NODE, &srv6_cmd);
 	install_element(SEGMENT_ROUTING_NODE, &no_srv6_cmd);
 	install_element(SRV6_NODE, &srv6_locators_cmd);
+	install_element(SRV6_NODE, &srv6_encap_cmd);
 	install_element(SRV6_LOCS_NODE, &srv6_locator_cmd);
 	install_element(SRV6_LOCS_NODE, &no_srv6_locator_cmd);
 
-- 
2.20.1


From c53c68d4f9a1f9ab73c670f139835375b78092d6 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Thu, 3 Nov 2022 08:40:39 +0100
Subject: [PATCH 12/16] vtysh: Add CLI node for SRv6 encap parameters

This commit adds a new node `SRV6_ENCAP_NODE` to the CLI graph. This
node provides configuration parameters related to the SRv6
encapsulation.

```
router# segment-routing
router(sr)# srv6
router(srv6)# encapsulation
router(srv6-encap)#
```

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 vtysh/vtysh.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/vtysh/vtysh.c b/vtysh/vtysh.c
index acc984ced..567b5587f 100644
--- a/vtysh/vtysh.c
+++ b/vtysh/vtysh.c
@@ -1330,6 +1330,13 @@ static struct cmd_node srv6_loc_node = {
 	.prompt = "%s(config-srv6-locator)# ",
 };
 
+static struct cmd_node srv6_encap_node = {
+	.name = "srv6-encap",
+	.node = SRV6_ENCAP_NODE,
+	.parent_node = SRV6_NODE,
+	.prompt = "%s(config-srv6-encap)# "
+};
+
 #ifdef HAVE_PBRD
 static struct cmd_node pbr_map_node = {
 	.name = "pbr-map",
@@ -1686,6 +1693,14 @@ DEFUNSH(VTYSH_ZEBRA, srv6_locator, srv6_locator_cmd,
 	return CMD_SUCCESS;
 }
 
+DEFUNSH(VTYSH_ZEBRA, srv6_encap, srv6_encap_cmd,
+	"encapsulation",
+	"Segment Routing SRv6 encapsulation\n")
+{
+	vty->node = SRV6_ENCAP_NODE;
+	return CMD_SUCCESS;
+}
+
 #ifdef HAVE_BGPD
 DEFUNSH(VTYSH_BGPD, router_bgp, router_bgp_cmd,
 	"router bgp [(1-4294967295) [<view|vrf> VIEWVRFNAME]]",
@@ -2427,6 +2442,14 @@ DEFUNSH(VTYSH_ZEBRA, exit_srv6_loc_config, exit_srv6_loc_config_cmd, "exit",
 	return CMD_SUCCESS;
 }
 
+DEFUNSH(VTYSH_ZEBRA, exit_srv6_encap, exit_srv6_encap_cmd, "exit",
+	"Exit from SRv6-encapsulation configuration mode\n")
+{
+	if (vty->node == SRV6_ENCAP_NODE)
+		vty->node = SRV6_NODE;
+	return CMD_SUCCESS;
+}
+
 #ifdef HAVE_RIPD
 DEFUNSH(VTYSH_RIPD, vtysh_exit_ripd, vtysh_exit_ripd_cmd, "exit",
 	"Exit current mode and down to previous mode\n")
@@ -4894,6 +4917,7 @@ void vtysh_init_vty(void)
 	install_element(SRV6_NODE, &srv6_locators_cmd);
 	install_element(SRV6_NODE, &exit_srv6_config_cmd);
 	install_element(SRV6_NODE, &vtysh_end_all_cmd);
+	install_element(SRV6_NODE, &srv6_encap_cmd);
 
 	install_node(&srv6_locs_node);
 	install_element(SRV6_LOCS_NODE, &srv6_locator_cmd);
@@ -4904,6 +4928,10 @@ void vtysh_init_vty(void)
 	install_element(SRV6_LOC_NODE, &exit_srv6_loc_config_cmd);
 	install_element(SRV6_LOC_NODE, &vtysh_end_all_cmd);
 
+	install_node(&srv6_encap_node);
+	install_element(SRV6_ENCAP_NODE, &exit_srv6_encap_cmd);
+	install_element(SRV6_ENCAP_NODE, &vtysh_end_all_cmd);
+
 	install_element(ENABLE_NODE, &vtysh_show_running_config_cmd);
 	install_element(ENABLE_NODE, &vtysh_copy_running_config_cmd);
 	install_element(ENABLE_NODE, &vtysh_copy_to_running_cmd);
-- 
2.20.1


From e6a9ac88fb1ed1f802e96ddceb32cfce047a09f0 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Wed, 2 Nov 2022 20:04:05 +0100
Subject: [PATCH 13/16] zebra: Add CLI cmd to set SRv6 encap source addr

In this commit, we install a new CLI command `source-address` under the
`SRV6_ENCAP_NODE` node. This command is used to configure the source
address of the outer encapsulating IPv6 header.

```
router# segment-routing
router(sr)# srv6
router(srv6)# encapsulation
router(srv6-encap)# source-address fc00:0:1::1
```

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/zebra_srv6_vty.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index 892da125c..5f5698f7a 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -420,6 +420,17 @@ DEFUN_NOSH (srv6_encap,
 	return CMD_SUCCESS;
 }
 
+DEFPY (srv6_src_addr,
+       srv6_src_addr_cmd,
+       "source-address X:X::X:X$encap_src_addr",
+       "Segment Routing SRv6 source address\n"
+       "Specify source address for SRv6 encapsulation\n")
+{
+	zebra_srv6_encap_src_addr_set(&encap_src_addr);
+	dplane_sr_tunsrc_set(&encap_src_addr, NS_DEFAULT);
+	return CMD_SUCCESS;
+}
+
 static int zebra_sr_config(struct vty *vty)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
@@ -492,6 +503,7 @@ void zebra_srv6_vty_init(void)
 	/* Command for configuration */
 	install_element(SRV6_LOC_NODE, &locator_prefix_cmd);
 	install_element(SRV6_LOC_NODE, &locator_behavior_cmd);
+	install_element(SRV6_ENCAP_NODE, &srv6_src_addr_cmd);
 
 	/* Command for operation */
 	install_element(VIEW_NODE, &show_srv6_locator_cmd);
-- 
2.20.1


From 09db561db66101b6db2b8eb6c1f4ea237c00a41c Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Wed, 2 Nov 2022 20:05:02 +0100
Subject: [PATCH 14/16] zebra: Add CLI cmd to clear SRv6 encap src addr

In this commit, we install a new CLI command `no_srv6_src_addr_cmd`
under the `SRV6_ENCAP_NODE` node. This command is used to unset the
source address of the outer encapsulating IPv6 header and restore the
default source address.

```
router# segment-routing
router(sr)# srv6
router(srv6)# encapsulation
router(srv6-encap)# no source-address
```

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/zebra_srv6_vty.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index 5f5698f7a..ddb4fbdce 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -431,6 +431,18 @@ DEFPY (srv6_src_addr,
 	return CMD_SUCCESS;
 }
 
+DEFPY (no_srv6_src_addr,
+       no_srv6_src_addr_cmd,
+       "no source-address [X:X::X:X$encap_src_addr]",
+       NO_STR
+       "Segment Routing SRv6 source address\n"
+       "Specify source address for SRv6 encapsulation\n")
+{
+	zebra_srv6_encap_src_addr_unset();
+	dplane_sr_tunsrc_set(&in6addr_any, NS_DEFAULT);
+	return CMD_SUCCESS;
+}
+
 static int zebra_sr_config(struct vty *vty)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
@@ -504,6 +516,7 @@ void zebra_srv6_vty_init(void)
 	install_element(SRV6_LOC_NODE, &locator_prefix_cmd);
 	install_element(SRV6_LOC_NODE, &locator_behavior_cmd);
 	install_element(SRV6_ENCAP_NODE, &srv6_src_addr_cmd);
+	install_element(SRV6_ENCAP_NODE, &no_srv6_src_addr_cmd);
 
 	/* Command for operation */
 	install_element(VIEW_NODE, &show_srv6_locator_cmd);
-- 
2.20.1


From de0f9d35837777013928d2056135330532e61b77 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Fri, 4 Nov 2022 19:28:04 +0100
Subject: [PATCH 15/16] zebra: Add CLI command to `show srv6 information`

This commit adds a new CLI command `show srv6 information` that is used
to print the SRv6 information. Currently, the SRv6 information includes
the SRv6 encapsulation source address and the SRv6 locators configured
in zebra.

Below is an example of the output of the `show srv6 information`
command:

```
router# show segment-routing srv6 json
{
  "encapsulation":{
    "sourceAddress":"1111:2222:3333:4444::8888"
  },
  "locators":[
    {
      "name":"loc1",
      "prefix":"fc00:0:1::/64",
      "functionBitsLength":16,
      "statusUp":true,
      "chunks":[
        {
          "prefix":"fc00:0:1::/64",
          "proto":"bgp"
        }
      ]
    }
  ]
}
```

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/zebra_srv6_vty.c | 58 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index ddb4fbdce..b5cb47496 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -81,6 +81,63 @@ static struct cmd_node srv6_encap_node = {
 	.prompt = "%s(config-srv6-encap)# "
 };
 
+DEFPY (show_srv6,
+       show_srv6_cmd,
+       "show segment-routing srv6 [json]",
+       SHOW_STR
+       "Segment Routing\n"
+       "Segment Routing SRv6\n"
+       JSON_STR)
+{
+	const bool uj = use_json(argc, argv);
+	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
+	struct srv6_locator *locator;
+	struct listnode *node;
+	int id;
+	json_object *json = NULL;
+	json_object *json_locators = NULL;
+	json_object *json_locator = NULL;
+	json_object *json_encapsulation = NULL;
+
+	if (uj) {
+		json = json_object_new_object();
+		json_locators = json_object_new_array();
+		json_encapsulation = json_object_new_object();
+		json_object_object_add(json, "encapsulation",
+				       json_encapsulation);
+		json_object_object_add(json, "locators", json_locators);
+
+		for (ALL_LIST_ELEMENTS_RO(srv6->locators, node, locator)) {
+			json_locator = srv6_locator_json(locator);
+			if (!json_locator)
+				continue;
+			json_object_array_add(json_locators, json_locator);
+		}
+
+		json_object_string_addf(json_encapsulation, "sourceAddress",
+					"%pI6", &srv6->encap_src_addr);
+
+		vty_json(vty, json);
+	} else {
+		vty_out(vty, "Encapsulation:\n");
+		vty_out(vty, "  Source-Address: %pI6\n", &srv6->encap_src_addr);
+		vty_out(vty, "Locator:\n");
+		vty_out(vty, "Name                 ID      Prefix                   Status\n");
+		vty_out(vty, "-------------------- ------- ------------------------ -------\n");
+
+		id = 1;
+		for (ALL_LIST_ELEMENTS_RO(srv6->locators, node, locator)) {
+			vty_out(vty, "%-20s %-7d %-24pFX %s\n", locator->name,
+				id, &locator->prefix,
+				locator->status_up ? "Up" : "Down");
+			++id;
+		}
+		vty_out(vty, "\n");
+	}
+
+	return CMD_SUCCESS;
+}
+
 DEFUN (show_srv6_locator,
        show_srv6_locator_cmd,
        "show segment-routing srv6 locator [json]",
@@ -521,4 +578,5 @@ void zebra_srv6_vty_init(void)
 	/* Command for operation */
 	install_element(VIEW_NODE, &show_srv6_locator_cmd);
 	install_element(VIEW_NODE, &show_srv6_locator_detail_cmd);
+	install_element(VIEW_NODE, &show_srv6_cmd);
 }
-- 
2.20.1


From 1d75e1b93df21dd032c6839e9b7f0c16a3f98799 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
Date: Mon, 5 Sep 2022 19:23:54 +0200
Subject: [PATCH 16/16] zebra: Add SRv6 encap info to the SRv6 config

In this commit, we extend the zebra SRv6 configuration to include the
SRv6 encapsulation information.

Signed-off-by: Carmine Scarpitta <carmine.scarpitta@uniroma2.it>
---
 zebra/zebra_srv6_vty.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/zebra/zebra_srv6_vty.c b/zebra/zebra_srv6_vty.c
index b5cb47496..3080b3ed1 100644
--- a/zebra/zebra_srv6_vty.c
+++ b/zebra/zebra_srv6_vty.c
@@ -511,6 +511,11 @@ static int zebra_sr_config(struct vty *vty)
 	if (zebra_srv6_is_enable()) {
 		vty_out(vty, "segment-routing\n");
 		vty_out(vty, " srv6\n");
+		if (!IPV6_ADDR_SAME(&srv6->encap_src_addr, &in6addr_any)) {
+			vty_out(vty, "  encapsulation\n");
+			vty_out(vty, "   source-address %pI6\n",
+				&srv6->encap_src_addr);
+		}
 		vty_out(vty, "  locators\n");
 		for (ALL_LIST_ELEMENTS_RO(srv6->locators, node, locator)) {
 			inet_ntop(AF_INET6, &locator->prefix.prefix,
-- 
2.20.1

